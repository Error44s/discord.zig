name: PullApprove (Lite)

on:
  pull_request_target:
    types: [opened, ready_for_review, reopened, synchronize, review_requested, review_request_removed, closed]
  pull_request_review:
    types: [submitted, edited, dismissed]

permissions:
  contents: read
  pull-requests: write
  issues: write
  checks: write

concurrency:
  group: pa-lite-${{ github.event.pull_request.node_id || github.run_id }}
  cancel-in-progress: true

jobs:
  gate:
    if: github.event.action != 'closed'
    runs-on: ubuntu-latest
    steps:
      - name: Auto request reviews from CODEOWNERS
        if: github.event_name == 'pull_request_target' && github.event.pull_request.draft == false
        uses: necojackarc/auto-request-review@v0.7.0
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          config: .github/CODEOWNERS

      - name: Fallback request to core team if none requested
        if: github.event_name == 'pull_request_target' && github.event.pull_request.draft == false
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const prNum = context.payload.pull_request.number;
            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNum });
            const noUsers = (pr.requested_reviewers || []).length === 0;
            const noTeams = (pr.requested_teams || []).length === 0;
            if (noUsers && noTeams) {
              await github.rest.pulls.requestReviewers({
                owner, repo, pull_number: prNum,
                team_reviewers: ["core"]
              }).catch(() => {});
            }

      - name: Evaluate approvals and update labels/check
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const pr    = context.payload.pull_request;
            if (!pr) return core.setFailed("No pull_request in payload.");
            const number = pr.number;

            const REQUIRED = 1;
            const LABELS = {
              pending:  ["PA: Maintainers pending", "PA: All Contributors pending"],
              approved: ["PA: Maintainers approved", "PA: All Contributors approved"]
            };
            const COLORS = {
              "PA: Maintainers pending":  "c5def5",
              "PA: All Contributors pending": "c5def5",
              "PA: Maintainers approved": "bfe5bf",
              "PA: All Contributors approved": "bfe5bf",
              "Merge: successful": "0e8a16",
              "Merge: declined":   "d93f0b",
              "Reopened":          "0366d6"
            };

            const reviews = await github.paginate(
              github.rest.pulls.listReviews,
              { owner, repo, pull_number: number, per_page: 100 }
            );
            const latest = new Map();
            for (const r of reviews) latest.set(r.user.login, r.state);
            const approvals = [...latest.values()].filter(s => s === "APPROVED").length;
            const ok = approvals >= REQUIRED;

            async function ensure(name) {
              try { await github.rest.issues.getLabel({ owner, repo, name }); }
              catch { await github.rest.issues.createLabel({ owner, repo, name, color: COLORS[name] || "ededed" }).catch(() => {}); }
            }
            for (const n of [...LABELS.pending, ...LABELS.approved, "Merge: successful","Merge: declined","Reopened"]) await ensure(n);

            const { data: cur } = await github.rest.issues.listLabelsOnIssue({ owner, repo, issue_number: number });
            const have = new Set(cur.map(l => l.name));
            const add = ok ? LABELS.approved : LABELS.pending;
            const rm  = ok ? LABELS.pending  : LABELS.approved;

            if (add.some(n => !have.has(n))) {
              await github.rest.issues.addLabels({ owner, repo, issue_number: number, labels: add }).catch(() => {});
            }
            for (const n of rm) if (have.has(n)) {
              await github.rest.issues.removeLabel({ owner, repo, issue_number: number, name: n }).catch(() => {});
            }
            for (const n of ["Merge: successful","Merge: declined","Reopened"]) if (have.has(n)) {
              await github.rest.issues.removeLabel({ owner, repo, issue_number: number, name: n }).catch(() => {});
            }

            await github.rest.checks.create({
              owner, repo,
              name: "PullApprove (Lite)",
              head_sha: pr.head.sha,
              status: "completed",
              completed_at: new Date().toISOString(),
              conclusion: ok ? "success" : "failure",
              output: {
                title: ok ? `Approved (${approvals}/${REQUIRED})` : `Waiting for approvals (${approvals}/${REQUIRED})`,
                summary: ok ? "Required approvals met. You can merge." : "Not enough approvals yet. Request reviews from CODEOWNERS."
              }
            });

  state:
    if: github.event_name == 'pull_request_target' && (github.event.action == 'closed' || github.event.action == 'reopened')
    runs-on: ubuntu-latest
    steps:
      - name: Update state labels
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const pr    = context.payload.pull_request;
            if (!pr) return;
            const number = pr.number;

            const COLORS = {
              "Merge: successful": "0e8a16",
              "Merge: declined":   "d93f0b",
              "Reopened":          "0366d6"
            };
            async function ensure(name) {
              try { await github.rest.issues.getLabel({ owner, repo, name }); }
              catch { await github.rest.issues.createLabel({ owner, repo, name, color: COLORS[name] || "ededed" }).catch(() => {}); }
            }
            for (const n of Object.keys(COLORS)) await ensure(n);

            const { data: cur } = await github.rest.issues.listLabelsOnIssue({ owner, repo, issue_number: number });
            const have = new Set(cur.map(l => l.name));
            const purge = [...have].filter(n => n.startsWith("PA: ") || ["Merge: successful","Merge: declined","Reopened"].includes(n));
            for (const n of purge) await github.rest.issues.removeLabel({ owner, repo, issue_number: number, name: n }).catch(() => {});

            if (context.payload.action === "reopened") {
              await github.rest.issues.addLabels({ owner, repo, issue_number: number, labels: ["Reopened"] }).catch(() => {});
            } else if (context.payload.action === "closed") {
              await github.rest.issues.addLabels({
                owner, repo, issue_number: number,
                labels: [pr.merged ? "Merge: successful" : "Merge: declined"]
              }).catch(() => {});
            }
