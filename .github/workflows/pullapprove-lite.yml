name: PullApprove (Lite)

on:
  pull_request_target:
    types: [opened, ready_for_review, reopened, synchronize, review_requested, review_request_removed, closed]
  pull_request_review:
    types: [submitted, edited, dismissed]

permissions:
  contents: read
  pull-requests: write
  issues: write
  checks: write

concurrency:
  group: pa-lite-${{ github.event.pull_request.node_id || github.run_id }}
  cancel-in-progress: true

jobs:
  gate:
    if: github.event.action != 'closed'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Request reviewers from CODEOWNERS
        if: github.event_name == 'pull_request_target' && github.event.pull_request.draft == false
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const pr    = context.payload.pull_request;
            const prNum = pr.number;

            const p = path.join(process.cwd(), '.github', 'CODEOWNERS');
            if (!fs.existsSync(p)) return;
            const raw = fs.readFileSync(p, 'utf8');

            const toRegex = (pat) => {
              let s = pat.trim()
                .replace(/([.+^=!:${}()|[\]\\])/g, '\\$1')
                .replace(/\*\*/g, '::DS::')
                .replace(/\*/g, '[^/]*')
                .replace(/::DS::/g, '.*')
                .replace(/\?/g, '[^/]');
              if (s.startsWith('/')) s = '^' + s.slice(1);
              else s = '(?:.*/)?' + s + '$';
              return new RegExp(s.endsWith('$') ? s : s + '$');
            };

            const rules = [];
            for (const line of raw.split(/\r?\n/)) {
              const t = line.trim();
              if (!t || t.startsWith('#')) continue;
              const parts = t.split(/\s+/);
              const pattern = parts.shift();
              const owners  = parts.filter(Boolean);
              if (!pattern || owners.length === 0) continue;
              rules.push({ re: toRegex(pattern), owners });
            }

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner, repo, pull_number: prNum, per_page: 100
            });
            const changed = files.map(f => f.filename);

            const users = new Set();
            const teams = new Set();
            for (const file of changed) {
              let match = null;
              for (const r of rules) if (r.re.test(file)) match = r;
              if (match) {
                for (const o of match.owners) {
                  if (!o.startsWith('@')) continue;
                  const id = o.slice(1);
                  const parts = id.split('/');
                  if (parts.length === 2) teams.add(parts[1]);
                  else users.add(id);
                }
              }
            }

            const { data: prFull } = await github.rest.pulls.get({ owner, repo, pull_number: prNum });
            const hasUsers = (prFull.requested_reviewers || []).length > 0;
            const hasTeams = (prFull.requested_teams || []).length > 0;

            if (!hasUsers && !hasTeams && users.size === 0 && teams.size === 0) {
              teams.add('core');
            }

            if (users.size || teams.size) {
              await github.rest.pulls.requestReviewers({
                owner, repo, pull_number: prNum,
                reviewers: [...users],
                team_reviewers: [...teams]
              }).catch(() => {});
            }

      - name: Evaluate approvals and update labels/check
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const pr    = context.payload.pull_request;
            if (!pr) return core.setFailed("No pull_request in payload.");
            const number = pr.number;

            const REQUIRED = 1;
            const LABELS = {
              pending:  ["PA: Maintainers pending", "PA: All Contributors pending"],
              approved: ["PA: Maintainers approved", "PA: All Contributors approved"]
            };
            const COLORS = {
              "PA: Maintainers pending":  "c5def5",
              "PA: All Contributors pending": "c5def5",
              "PA: Maintainers approved": "bfe5bf",
              "PA: All Contributors approved": "bfe5bf",
              "Merge: successful": "0e8a16",
              "Merge: declined":   "d93f0b",
              "Reopened":          "0366d6"
            };

            const reviews = await github.paginate(
              github.rest.pulls.listReviews,
              { owner, repo, pull_number: number, per_page: 100 }
            );
            const latest = new Map();
            for (const r of reviews) latest.set(r.user.login, r.state);
            const approvals = [...latest.values()].filter(s => s === "APPROVED").length;
            const ok = approvals >= REQUIRED;

            async function ensure(name) {
              try { await github.rest.issues.getLabel({ owner, repo, name }); }
              catch { await github.rest.issues.createLabel({ owner, repo, name, color: COLORS[name] || "ededed" }).catch(() => {}); }
            }
            for (const n of [...LABELS.pending, ...LABELS.approved, "Merge: successful","Merge: declined","Reopened"]) await ensure(n);

            const { data: cur } = await github.rest.issues.listLabelsOnIssue({ owner, repo, issue_number: number });
            const have = new Set(cur.map(l => l.name));
            const add = ok ? LABELS.approved : LABELS.pending;
            const rm  = ok ? LABELS.pending  : LABELS.approved;

            if (add.some(n => !have.has(n))) {
              await github.rest.issues.addLabels({ owner, repo, issue_number: number, labels: add }).catch(() => {});
            }
            for (const n of rm) if (have.has(n)) {
              await github.rest.issues.removeLabel({ owner, repo, issue_number: number, name: n }).catch(() => {});
            }
            for (const n of ["Merge: successful","Merge: declined","Reopened"]) if (have.has(n)) {
              await github.rest.issues.removeLabel({ owner, repo, issue_number: number, name: n }).catch(() => {});
            }

            await github.rest.checks.create({
              owner, repo,
              name: "PullApprove (Lite)",
              head_sha: pr.head.sha,
              status: "completed",
              completed_at: new Date().toISOString(),
              conclusion: ok ? "success" : "failure",
              output: {
                title: ok ? `Approved (${approvals}/${REQUIRED})` : `Waiting for approvals (${approvals}/${REQUIRED})`,
                summary: ok ? "Required approvals met. You can merge." : "Not enough approvals yet. Request reviews from CODEOWNERS."
              }
            });

  state:
    if: github.event_name == 'pull_request_target' && (github.event.action == 'closed' || github.event.action == 'reopened')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Update state labels
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const pr    = context.payload.pull_request;
            if (!pr) return;

            const COLORS = {
              "Merge: successful": "0e8a16",
              "Merge: declined":   "d93f0b",
              "Reopened":          "0366d6"
            };
            async function ensure(name) {
              try { await github.rest.issues.getLabel({ owner, repo, name }); }
              catch { await github.rest.issues.createLabel({ owner, repo, name, color: COLORS[name] || "ededed" }).catch(() => {}); }
            }
            for (const n of Object.keys(COLORS)) await ensure(n);

            const { data: cur } = await github.rest.issues.listLabelsOnIssue({ owner, repo, issue_number: pr.number });
            const have = new Set(cur.map(l => l.name));
            const purge = [...have].filter(n => n.startsWith("PA: ") || ["Merge: successful","Merge: declined","Reopened"].includes(n));
            for (const n of purge) await github.rest.issues.removeLabel({ owner, repo, issue_number: pr.number, name: n }).catch(() => {});

            if (context.payload.action === "reopened") {
              await github.rest.issues.addLabels({ owner, repo, issue_number: pr.number, labels: ["Reopened"] }).catch(() => {});
            } else if (context.payload.action === "closed") {
              await github.rest.issues.addLabels({
                owner, repo, issue_number: pr.number,
                labels: [pr.merged ? "Merge: successful" : "Merge: declined"]
              }).catch(() => {});
            }
